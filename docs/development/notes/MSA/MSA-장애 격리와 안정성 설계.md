# resilience.md – MSA의 장애 격리와 안정성 설계

## Resilience(회복력)가 중요한가?
> MSA에서는 서비스가 많고 네트워크로 연결되므로  
> **한 서비스의 장애가 전체 장애로 확산될 위험이 있음**

### 예시 상황
- `Payment Service` 장애
- `Booking Service`가 무한 대기 or 계속 재시도
- 전체 서비스가 지연/다운되는 **연쇄 장애 발생**

---

## 장애 대응 핵심 전략
| 전략 | 설명 |
|------|------|
| Circuit Breaker | 실패가 일정 횟수 이상 반복되면 호출 차단 |
| Retry | 일시적인 실패일 경우 자동 재시도 |
| Fallback | 실패 시 대체 로직 실행 |
| Timeout | 일정 시간 초과 시 요청 강제 중단 |
| Bulkhead | 자원 분리로 서비스 간 영향 최소화 |

---

## Circuit Breaker (회로 차단기)
> 반복된 실패가 발생하면 **일시적으로 호출 차단**  
→ 전체 장애 확산 방지

### 상태 흐름
- `Closed` : 정상 호출
- `Open` : 호출 차단
- `Half-Open` : 일부 호출로 상태 확인 후 회복 여부 판단

---

## Retry (재시도)
> 예외나 네트워크 오류 시 **자동으로 재시도**  
→ 일시적 오류 극복 가능, 너무 많은 재시도는 오히려 시스템을 더 느리게 만들 수 있음

---

## Fallback (대체 처리)
> 실패 시 **캐시된 응답, 안내 메시지, 기본 응답** 등을 제공  
→ 사용자 경험을 보호하고 장애 파급을 줄임

---

## Timeout (타임아웃)
> 일정 시간 동안 응답이 없으면 **강제로 호출 중단**

- 기본값 설정 필수 (예: 3초)
- 무한 대기는 전체 서비스 지연의 원인

---

## Bulkhead (격벽 패턴)
> 서비스 간 자원(ThreadPool 등)을 분리하여  
> **하나의 과부하가 다른 서비스에 영향을 주지 않도록 차단**

---

## 장애 격리 전략 요약
| 전략 | 목적 | 대표 도구 |
|------|------|------------|
| **Circuit Breaker** | 장애 전파 차단 | Resilience4j |
| **Retry** | 일시적 실패 복구 | Spring Retry, Resilience4j |
| **Fallback** | 대체 응답 제공 | 메서드 정의, 캐시 활용 |
| **Timeout** | 무한 대기 방지 | RestTemplate/WebClient 설정 |
| **Bulkhead** | 자원 고립화 | ThreadPool 격리, 리소스 제한 |

---

## 장애 회복 설계 시 주의사항
| 항목 | 설명 |
|------|------|
| 무조건 재시도는 안됨 | 장애 상황 악화, 부하 폭증 가능 |
| fallback도 실패할 수 있음 | fallback 내부 예외 대비 로직 필요 |
| Circuit Breaker 임계값 | 너무 민감하면 자주 Open → 장애처럼 동작 |
| Timeout 설정 | 전체 호출 흐름 타임라인 고려해서 조정 필요 |
| Bulkhead 과도 격리 | 과도하게 고립하면 오히려 비효율 증가 |

---

## 정리 요약
- 마이크로서비스는 **“장애가 발생할 수 있다”는 전제를 가지고 설계해야 함**
- **회복 가능한 구조(Circuit Breaker, Retry, Fallback 등)**를 통해 시스템 전체 장애를 막을 수 있음
- Spring에서는 `Resilience4j`를 통해 쉽게 적용 가능
- 장애를 피하는 것보다, **장애를 우아하게 견디는 시스템**을 만드는 것이 핵심