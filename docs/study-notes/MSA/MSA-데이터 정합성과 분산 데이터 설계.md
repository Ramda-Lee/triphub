# Microservices – 데이터 정합성과 분산 데이터 설계

## MSA에서 데이터는 왜 분리해야 할까?
| 이유 | 설명 |
|------|------|
| 독립 배포 보장 | 각 서비스가 자신의 DB만 쓰면 배포 충돌 없음 |
| 느슨한 결합 | 다른 서비스 DB를 직접 참조하지 않음 |
| 보안/권한 분리 | 서비스별로 데이터 접근을 통제 가능 |
| 장애 격리 | 한 서비스 DB 장애가 전체 시스템에 영향 없음 |

---

## 하지만 데이터 분리를 하면 발생하는 문제
> "그럼 서로 필요한 데이터를 어떻게 공유하지?"

- 서비스 간 데이터 중복
- 실시간으로 일관된 상태 유지 어려움
- 전통적인 트랜잭션(ACID) 불가능
- 정합성 무너질 위험 (예: 예약은 됐는데 결제 실패)

---

## 정합성(Consistency)이란?
> 여러 시스템에 걸쳐 있는 데이터가  
> **"서로 충돌 없이 논리적으로 일치되는 상태"**

---

## 해결 전략 1: **Eventual Consistency (결국 일관성)**
> 즉각 반영이 아닌, 시간이 지나면 결국 일치되게 만드는 전략

### 예시:
- 예약 생성 → Kafka 이벤트 발행
- 결제 서비스에서 이벤트 수신 후 처리
- 실패 시 보상 트랜잭션으로 취소

“결제는 1초 늦게 처리돼도 괜찮지만, 결국은 맞아야 한다”는 사고 방식

---

## 해결 전략 2: **SAGA 패턴**
> MSA에서 분산 트랜잭션을 해결하기 위한 대표 패턴  
> 여러 서비스의 로컬 트랜잭션을 이벤트로 연결하고,  
> 실패 시 **보상 트랜잭션**을 통해 정합성 복구

### SAGA 패턴 방식

#### 1. Choreography (이벤트 기반)
- 서비스 간 직접 이벤트 주고받음 (Kafka 등 사용)
- 서비스들이 자율적으로 보상 처리 수행

#### 2. Orchestration (중앙 제어)
- SAGA Orchestrator가 전체 트랜잭션 흐름 제어
- 각 서비스에 명령 → 응답 받기 → 다음 단계 제어

---

## 구현 도구 (Spring 기반 예시)
| 기술 | 역할 |
|------|------|
| Kafka | 이벤트 발행/수신 |
| @Transactional | 각 서비스 내부 로컬 트랜잭션 |
| Spring Retry | 재시도 로직 |
| State Machine | SAGA 상태 추적 |
| Dead Letter Queue | 실패 이벤트 재처리 |

---

## 데이터 정합성을 지키기 위한 설계 원칙
| 원칙 | 설명 |
|------|------|
| DB 공유 금지 | 절대 다른 서비스 DB 직접 참조 X |
| 상태 전이 최소화 | 가능한 한 상태 변화는 이벤트로 제어 |
| 실패 대비 설계 | 항상 실패할 수 있다는 전제에서 시작 |
| 비동기 처리 고려 | Kafka, 메시지 큐 등을 통한 느슨한 연결 설계 |
| 보상 트랜잭션 명확화 | 실패 시 어떻게 복구할 것인지 사전에 정의

---

## 조심해야 하는 실수
| 실수 | 문제점 |
|------|--------|
| 서비스 간 직접 DB 조회 | Coupling 증가 + 배포 충돌 위험 |
| 응답만 믿고 트랜잭션 처리 | 네트워크 지연/장애로 잘못된 흐름 발생 가능성 |
| 보상 로직 누락 | 실패 시 데이터가 꼬이는 위험 |

---

## 정리 요약
- MSA에서는 **서비스별 DB 분리**가 원칙
- 그로 인해 **정합성 문제**가 발생하며, 이를 해결하기 위한 전략 필요
- 대표 전략: **Eventual Consistency**, **SAGA 패턴**
- SAGA는 실패 시 보상 트랜잭션으로 흐름을 되돌리는 구조
- 정합성은 기술보다 설계가 더 중요 → 항상 실패를 고려한 구조 설계 필수