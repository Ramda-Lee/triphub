# MSA Architecture

## MSA란?

> MSA(Microservices Architecture)는 하나의 시스템을  
> **작고 독립적으로 배포 가능한 여러 서비스**로 분리하여 구성하는 아키텍처 스타일이다.

---

## MSA가 등장하게 된 배경

### 모놀리식(Monolithic) 아키텍처의 한계

| 한계점 | 설명 |
|--------|------|
| 코드가 점점 거대해짐 | 모든 기능이 하나의 프로젝트에 모임 |
| 하나만 수정해도 전체 배포 | 작은 변경에도 전체 재배포 발생 |
| 장애 전파 | 한 기능의 장애가 전체 시스템 장애로 이어짐 |
| 확장성 한계 | 특정 기능만 확장하고 싶어도 전체를 늘려야 함 |
| 팀 협업 어려움 | 여러 팀이 하나의 코드베이스에서 충돌 발생

---

## MSA의 핵심 철학

| 원칙 | 설명 |
|------|------|
| **작게 나누기 (Small Services)** | 작고 명확한 책임을 가진 서비스로 분리 |
| **독립 배포 (Independent Deployment)** | 각 서비스는 개별적으로 배포 가능 |
| **독립 스케일링 (Independent Scaling)** | 필요한 서비스만 확장 가능 |
| **기술 독립성 (Polyglot Tech)** | 서비스마다 다른 기술 스택도 가능 |
| **자율성 (Autonomous Teams)** | 서비스와 팀의 책임을 일치시킴 |
| **느슨한 결합 (Loose Coupling)** | 다른 서비스와 최소한으로만 연결됨 |

---

## MSA vs Monolithic 비교

| 항목 | Monolithic | Microservices |
|------|------------|----------------|
| 아키텍처 | 모든 기능이 하나 | 기능마다 독립 서비스 |
| 배포 | 전체 배포 | 개별 배포 가능 |
| 확장성 | 전체 확장 | 서비스별 확장 |
| 장애 영향 | 전체 시스템 영향 | 특정 서비스로 국한 가능 |
| 기술 선택 | 하나로 통일 | 서비스별 자유 |
| 팀 구조 | 기능별 분리 어려움 | 도메인/기능별 팀 분리 용이 |

---

## MSA 구조 예시
```
  [Frontend]
      ↓
  [API Gateway]
      ├── /user/** → User Service
      ├── /booking/** → Booking Service
      ├── /payment/** → Payment Service
```
- 각 서비스는 독립적으로 배포되고 유지보수됨
- 공통 처리(인증, 로깅 등)는 Gateway에서 처리
---

## MSA가 도입 후 개발문화

| 항목 | 변화 |
|------|------|
| 개발 조직 | 도메인/서비스 단위로 팀 운영 (DevOps 강화) |
| 테스트 | 단위 테스트 + 계약 기반 테스트 필요 |
| 배포 | 개별 서비스 단위 배포 (CI/CD 중요성 ↑) |
| 운영 | 서비스별 모니터링, 트레이싱 필요 |
| 설계 사고방식 | 기술 중심 → 도메인 중심으로 전환 필요 (DDD 필수)

---

## MSA의 단점

| 단점 | 설명 |
|------|------|
| 복잡도 ↑ | 분산 시스템이므로 구성, 운영 복잡함 |
| 네트워크 비용 | 서비스 간 통신 비용 발생 (지연, 장애 가능성) |
| 데이터 일관성 | DB 분리로 인한 정합성 문제 발생 |
| DevOps 필요 | 자동화되지 않으면 오히려 생산성 하락 |
| 테스트 복잡 | 통합 테스트, 흐름 테스트 설계 필요

---

## 그래서 언제 MSA를 도입해야 할까?

> MSA는 **“도입이 목표”가 아니라, 문제 해결을 위한 수단**이어야 한다.

### 도입을 고려할 수 있는 시점:

- 팀 규모가 커지고, 병렬 개발이 필요할 때
- 일부 기능만 자주 수정/배포해야 할 때
- 기능별로 확장성이 요구될 때
- 도메인 경계가 명확히 나뉠 때 (ex. 사용자, 예약, 결제)

---

## 정리 요약

- MSA는 **작은 서비스들의 조합**으로 구성된 아키텍처
- 목적은 **독립적인 배포, 확장, 책임, 유연성 확보**
- 대신 복잡성과 운영 부담도 함께 증가함
- **아키텍처 도입 이유를 명확히 하고**, 서비스 분리를 제대로 해야 성공 가능











## 프론트와 백엔드 통신 (대표적으로 사용하는 방식)
| 구간 | 방식 | 설명 |
|------|------|------|
| 프론트 → 백엔드 | REST (API Gateway 경유) | 사용자 요청은 빠른 응답이 필요함 |
| 백엔드 ↔ 백엔드 | Kafka (비동기) | 대량 트래픽, 이벤트 기반 처리에 적합 |

---

## Kafka를 사용하는 이유
- 비동기 처리로 응답 속도 향상
- 대량 트래픽 처리에 강함 (파티셔닝, 병렬 소비 가능)
- 장애 복구 가능 (메시지 저장, 재시도)
- 느슨한 결합 구조 구현

### Kafka 사용 예시
- 예약 생성 → Kafka 이벤트 발행 (`booking.created`)
- 결제 서비스에서 해당 이벤트 구독 후 결제 진행
- 결제 완료 → Kafka 이벤트 발행 (`payment.success`)
- 알림 서비스에서 해당 이벤트 구독 → 알림 전송

---

## REST vs Kafka
| 항목 | REST | Kafka |
|------|------|-------|
| 통신 방식 | 동기 | 비동기 |
| 트래픽 대응 | 낮음 | 매우 강함 |
| 장애 시 | 요청 실패 | 재시도 가능 |
| 확장성 | 제한적 | 수평 확장 가능 |
| 적합한 상황 | 실시간 요청 응답 | 비동기 이벤트, 대량 처리 |

---

## API Gateway의 역할
- 라우팅: 요청을 올바른 서비스로 전달
- 인증/인가 처리 (JWT, OAuth2 등)
- 공통 로깅, CORS, 속도 제한 등 처리
- 서비스 버전 관리

---

## DDD (Domain-Driven Design)란?
도메인(비즈니스 영역) 중심으로 시스템을 설계하는 접근 방식  
→ 복잡한 도메인을 명확히 표현하고, 기술보다 비즈니스 중심으로 모델링

### 주요 개념
| 개념 | 설명 |
|------|------|
| Entity | 고유 ID가 있는 비즈니스 객체 |
| Value Object | 값 자체로 의미가 있는 객체 (주소, 날짜 등) |
| Aggregate | 트랜잭션 일관성을 위한 루트 객체 |
| Domain Service | 여러 Entity에 걸친 비즈니스 로직 |
| Bounded Context | 도메인 간 의미와 책임을 구분하는 경계 |
| Ubiquitous Language | 개발자와 도메인 전문가가 공유하는 용어 |

---

## 왜 DDD가 MSA에서 중요한가?
| 이유 | 설명 |
|------|------|
| 서비스 분리 기준 제공 | Bounded Context 기준으로 마이크로서비스 설계 가능 |
| 느슨한 결합 구현 | 도메인 간 직접 참조 없이 메시지 기반 통신 가능 |
| 유지보수성 향상 | 각 서비스가 도메인 중심으로 책임을 명확히 가짐 |

---

## 트랜잭션 처리 – SAGA 패턴
MSA에서는 DB 트랜잭션이 끊기기 때문에 보상 트랜잭션 기반으로 흐름 제어

**예시**
1. 예약 생성
2. Kafka에 "booking.created" 이벤트 발행
3. 결제 서비스 처리
4. 실패 시 Kafka로 "payment.failed" 이벤트 발행
5. 예약 서비스가 이벤트 수신 → 예약 취소 (보상 트랜잭션)
